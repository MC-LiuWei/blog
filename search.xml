<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端配置化项目思考</title>
      <link href="/2020/03/26/FrontendConfigurationProjectThinking/"/>
      <url>/2020/03/26/FrontendConfigurationProjectThinking/</url>
      
        <content type="html"><![CDATA[<p>进入项目已经两个多月了，慢慢对项目有了一点感觉。结合同事的讲解看，总体来说方案还是很快捷的。只是感觉似乎还有些点不太完善，同时觉得这个方案做的早了一点，并且留的时间似乎不多，如果继续在上面加逻辑后面应该会比较臃肿。目前的一点想法，是早上洗澡的闲暇者无事想的，或许不是太完善先记录一点可能后面再深入熟悉会有一定完善。还有就是这个方案玩久了人是没有编程能力的，对于开发它的危害性是大于对业务的好处，况且它并不是对业务完全友好的。</p><h2 id="目前的方案"><a href="#目前的方案" class="headerlink" title="目前的方案"></a>目前的方案</h2><h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><p>前端在平台上分为安卓、ios、web,主要功能还是以web的方式呈现，ios和安卓使用web容器展示。属于全球招聘计划，表单流程为主。目前的方案是通过配置实现前端页面渲染同时控制前后交互的逻辑，在前端这边定制好视图后扩展基本靠配置。这个部分是针对业务实现和扩展来做的，还有一部分是代码设计部分。从大的结构看，分为流程控制部分、异常部分、表单渲染及主题配置。</p><p><img src="/imgs/flow-one.png?center" alt="概述"></p><p>前端使用的<code>react</code>所以整套方案最主要的是利用大量的<code>hook</code>去管理状态，并且通过<code>useContext</code>实现分层。来说说为什么选这样的方案，出发点是一套web代码多处使用，同时能快速通过配置扩展出一个市场。然而这种说法不知道多少人喊，好与不好再说吧。</p><h3 id="从服务到配置到前端"><a href="#从服务到配置到前端" class="headerlink" title="从服务到配置到前端"></a>从服务到配置到前端</h3><h4 id="核心url"><a href="#核心url" class="headerlink" title="核心url"></a>核心url</h4><p><img src="/imgs/cr_one.png?center" alt="基本关系"></p><p>在这个部分核心的依赖其实<code>makeBaseApi</code>这个块，它依赖访问的url中的参数构建一个基本的访问api。页面的最终渲染依赖于配置接口，流程查询接口，和数据支持接口三者缺一不可。首先进入页面会访问配置接口取出配置，配置里面包含<code>1.流程的控制配置以及对应页面的配置</code>,<code>2.页面渲染配置</code>,<code>3.接口调用配置</code>。从配置入手来看流程的处理方式，再说这样的方式约束性在哪里。图可能比较多，个人觉得这样比较直观一点吧。</p><p><img src="/imgs/cr_two.png" alt="流程控制"></p><h4 id="状态的管理与使用"><a href="#状态的管理与使用" class="headerlink" title="状态的管理与使用"></a>状态的管理与使用</h4><p>这里的状态其实分为两部分，依赖外部的（config接口）、内部控制的（当前提交数据和所处流程）。使用上游的数据来源都在一处-<code>context</code>，更新分两处，本地更新通过dispatch、外部更新通过next。由配置返回数据后，会把一些流程数据初始化到flowcontext本地，内部逻辑流转通过dispatch更改context再流回组件控制渲染，所以控制上其实条件更多的是依赖网络的另一方告诉，并且结构一定是完整的。说点题外话，大部分项目因为代码和业务的冲突没有处理好其实注定最后落不了地或者草草收尾的，这却又给了一些从业者学习的机会，它是好的！所以总需要存在这种情况。<br>1.第一个约束就是代码要适应配置的调整，配置变了代码其实就废了。这其实不太像配置化。<br>2.第二个矛盾在于这未必让业务扩展更快，当你的代码要适应配置改变而改变的时候，那就说明分支是没有用的，真正的分支控制由git转移到配置上了。在这上面因为对于配置依赖的方式决定了需要扩展出对配置的版本管理来避免多人开发的逻辑交叉。<br>3.交互方式与模块设计存在冲突，把流程控制抽出来放到npm，是要保持通用性实现多方依赖。将edit和model这类具象的状态引入其中，必然存在改页面逻辑需要去改npm包。污染公用控制层逻辑的同时更加大了冲突和异常的风险。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>对js使用双指针实现循环队列里的理解</title>
      <link href="/2020/03/19/Circularqueue/"/>
      <url>/2020/03/19/Circularqueue/</url>
      
        <content type="html"><![CDATA[<p>前两天从新的再走一遍leetcode的数据结构基础，又仔细看了看循环队列的实现。对于示例解答的基础代码仔细的看了看，发现有和我最开始的实现方式的操作，都是用push和shift之类的api去做的。对照着双指针的方案想，感觉还是别人的思路好，可以充分的考虑js数组的操作特性。重新回写一遍别人的方案，验证一下自己的理解。</p><pre><code class="js">class Circularqueue {    constructor(len) {        this.head = -1; // 出队列计数指针        this.footer = -1; // 入队列计数指针        this.queue = new Array(len);        this.length = this.queue.length;    }    insert(item) {        if (this.isFull()) return false;        if (this.isEmpty()) this.head = 0;        this.footer = (this.footer + 1)%this.length;        this.queue[this.footer] = item;        return true;    }    delete() {        if (!this.isEmpty()) {            if (this.head === this.footer) {                this.head = -1;                this.footer = -1;            } else {                this.head = (this.head + 1)%this.length;            }            return true;        }        return false;    }    read() {        if (!this.isEmpty()) return this.queue[this.footer];        return -1;    }    front() {        if (!this.isEmpty)) return this.queue[this.head];        return -1;    }    isFull() {        return (this.footer + 1)%this.length === this.head;    }    isEmpty() {        return this.head === -1;    }}</code></pre><h2 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h2><h4 id="队列的操作方式"><a href="#队列的操作方式" class="headerlink" title="队列的操作方式"></a>队列的操作方式</h4><blockquote><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表</p></blockquote><p>这个特点估计看一些面试题或者一些介绍已经听的耳熟能详的，不过有些时候是没办法理解好。就自己来看对于有些实现代码的理解可能是本末倒置的。对这段代码的理解我之前的思维方式就是，这样写的代码就是队列，这个应该不能算学习一些数据结构的基本知识，只记代码逻辑还是容易混淆特点的。</p><blockquote><p>顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素</p></blockquote><p>从上面描述的顺序队列的特点，也就知道样例代码里构造函数里这么写就是根据特点出发的。下次再写相关的就会知道要怎么写，而不是先回忆看过的代码，这样不会受他人的输出约束。再想熟练只能看在各种场景下对特点的应用了。回到循环队列上面，代码其实很基础，主要看优势和劣势的区别。</p><h4 id="push和shift的方式"><a href="#push和shift的方式" class="headerlink" title="push和shift的方式"></a>push和shift的方式</h4><p>从存储方式看，数组有索引和元素两点。在js里数组空间其实是动态的，越界的情况如果不设置控制逻辑可能只有在内存消耗完才会有并不是越界情况的内存溢出。用push和shift操作会直接的操作数据，删除增加元素，它的存储大小（length）会一直的变动。同时也会操作索引和元素的指向，了解过v8的垃圾处理其实知道在新老引用交替的过程中会出现非连续性的存储情况，最后会对这段存储空间重新做连续性处理。这个和对数组头尾操作是相似的。</p><pre><code class="js">let a = [1,2,3,4,5,6];console.log(a[1]); // 现在访问索引为1的元素是2a.shift();console.log(a[1]); // 现在访问索引为1的元素是3</code></pre><p>用shift操作中的一点是会引起数组的索引偏移，这个操作成本有点划不来，为了操作一个元素，要引起后面一连串的操作。用push虽然不会有偏移出现，但是数组的存储大小会改变。顺序队列没问题它可以是静态也可以动态，循环队列也可以，只是有点不太符合循环队列使队列空间重复利用的要求，重复利用是空间有限的情况。</p><h4 id="指针的利用"><a href="#指针的利用" class="headerlink" title="指针的利用"></a>指针的利用</h4><p>再来说在这个代码里对指针的最大化使用，感觉对编码里变量声名也是有一些帮助，有时候我们写代码会声名很多的变量，可是未必需要这么多也许一两个就能把功能做完，所以声名的时候也还是得考虑整个功能。这个里面头尾指针一共有三种作用，分别是：</p><h5 id="1-充当访问索引"><a href="#1-充当访问索引" class="headerlink" title="1.充当访问索引"></a>1.充当访问索引</h5><pre><code class="js">this.queue[this.footer] = item;if (!this.isEmpty()) return this.queue[this.footer];if (!this.isEmpty)) return this.queue[this.head];this.head = (this.head + 1)%this.length;this.footer = (this.footer + 1)%this.length;</code></pre><p>这个非常舒服，用头尾指针的移动模拟出队列的入队和出队，做到了只有在插入的时候替换原数组对应索引下元素最小化对数组的操作，稳定还高效。</p><h5 id="2-循环逻辑实现"><a href="#2-循环逻辑实现" class="headerlink" title="2.循环逻辑实现"></a>2.循环逻辑实现</h5><pre><code class="js">    insert(item) {        if (this.isFull()) return false;        if (this.isEmpty()) this.head = 0;        // 循环控制        this.footer = (this.footer + 1)%this.length;        this.queue[this.footer] = item;        return true;    }    delete() {        if (!this.isEmpty()) {            if (this.head === this.footer) {                // 循环控制                this.head = -1;                this.footer = -1;            } else {                // 循环控制                this.head = (this.head + 1)%this.length;            }            return true;        }        return false;    }</code></pre><p>在队列里能不能做插入和删除的前提是存储空间是不是满的或者是不是空的，既然用双指针去模拟删除插入也就不是真的去删除数组元素添加元素（替换）。那非空或者满的条件只有通过指针重合去实现。循环的处理主要利用取模的方式去处理头尾指针。</p><p><img src="/imgs/queuethree.png" alt="队列循环逻辑"></p><h2 id="循环队列的使用"><a href="#循环队列的使用" class="headerlink" title="循环队列的使用"></a>循环队列的使用</h2><p>循环队列一般被用作环形缓冲区。从业以来听的比较多的就是消息队列，单从消息队列来看，队列的使用主要为了减小服务端处理的压力。两个服务之间调用，每次调用的参数就好像是数组里的一个元素，只有真正被响应了才会从中清除。在前端处理一些高频率函数调用的时候有时也会需要这样的操作，本质上就是将本来在短期内需要处理的操作将它依次延后操作。循环缓冲区主要的区别在于定长的队列空间重复利用，这其实是对队列系统的内存使用空间控制。再形象点的联想这个循环缓冲还和前端的首页滚动横幅还是有那么点像呢。不过这个首页滚动横幅这个地方其实更像兵乓队列。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
